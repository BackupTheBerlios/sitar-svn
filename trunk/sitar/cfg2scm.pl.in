#!/usr/bin/perl
#
#  cfg2scm.pl - Check configuration changes into SCM
#  Copyright (C) 2005-2006 SuSE Linux, a Novell Business
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#  Authors/Contributors:
#		Matthias G. Eckermann
#		Günther Deschner	Manfred Hollstein
#

=head1 NAME

CFG2SCM - Check configuration changes into SCM

=head1 SYNOPSIS

cfg2scm.pl B<--check-consistency> B<--storage>=I<svn|cvs|tar|tar.gz|tar.bz2> B<--outfile>=I<file> B<--base-url>=I<url> B<--repository>=I<name> B<--username>=I<username> B<--password>=I<password> B<--message>=I<commit message> B<--help> B<--version>

=head1 DESCRIPTION

Check configuration changes into SCM (like SVN, CVS, ... or tar file)

=head1 OPTIONS

=over

=item B<--storage>=I<svn|cvs|tar|tar.gz|tar.bz2>

type of storage, either "svn", "cvs", "tar", "tar.gz" or "tar.bz2"

=item B<--outfile>=I<file> 

This option only works with storage-types tar, tar.gz, tar.bz2.
The extension is set automatically, if not given.

=item B<--base-url>=I<url>

url

=item B<--repository>=I<name>

name

=item B<--username>=I<username>

username

=item B<--password>=I<password>

password

=item B<--message>=I<commit message>

commit message

=item B<--help>

Prints a short summary of options.

=item B<--version>

Prints the cfg2scm.pl version

=item B<--check-consistency>

This option checks the consistency of configurations-files as declared in the RPMs, by invoking I<rpm -Vca>. It produces a file I</var/lib/support/Configuration_Consistency.include>, which is preserved between different cfg2scm.pl-runs.  The list contains all names of configuration files, which are tagged as configuration files within the RPMs and were changed compared to the release shipped within the RPMs.  

The following standard cfg2scm.pl-run includes the file I</var/lib/support/Configuration_Consistency.include>, as described below (section FILES) and commits the full content of the changed files.

Please note, that this really might need a long time (from 5-20 minutes).

=back

=head1 FILES

From a tool called C<PaDS> by Thorsten Wandersmann cfg2scm.pl inherited the ability, to extend the list of configuration files. To achieve that, just put a perl-snippet in the directory C</var/lib/support/>; this snippet B<must> have the extension C<.include> and may include only one perl-statement: an array-declaration for the array C<@files>, that contains the file-names with full path, see EXAMPLES below.

See also B<--check-consistency> above.

=head1 ERRORS

Enough:-|

=head1 DIAGNOSTICS

-

=head1 EXAMPLES

Check configuration files and commit everything.

C<cfg2scm.pl --check-consistency>

A typical file to include the configurations files of the application C<foobar> could look like this:

 # /var/lib/support/foobar.include
 
 @files= (
 	"/etc/opt/foobar/foo.conf",
 	"/etc/opt/foobar/bar.conf"
 	);

 # eof
 
=head1 AUTHOR

The CFG2SCM project was created by Matthias G. Eckermann <mge@suse.de>; many
thanks to Günther Deschner <gd@suse.de> and Manfred Hollstein <mh@novell.com>
for tips and code.

=head1 LICENSE

Copyright (C) 2005-2006 SuSE Linux, a Novell Business

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 675 Mass
Ave, Cambridge, MA 02139, USA. 

=cut

use Getopt::Long;
#
# commands
#
$ENV{ PATH } = '/sbin:/bin:/usr/bin:/usr/sbin:/opt/subversion/bin';
if ( !$CFG2SCM_OPT_DEBUG ) {
	open( SAVEERR, ">&STDERR" );
	open( STDERR,  ">/dev/null" );
}
chomp( my $CMD_BASENAME = `which basename` );
chomp( my $CMD_CAT      = `which cat` );
chomp( my $CMD_CVS      = `which cvs` );
chomp( my $CMD_DIRNAME  = `which dirname` );
chomp( my $CMD_FILE     = `which file` );
chomp( my $CMD_FIND     = `which find` );
chomp( my $CMD_GREP     = `which grep` );
chomp( my $CMD_GZIP     = `which gzip` );
chomp( my $CMD_HEAD     = `which head` );
chomp( my $CMD_HOSTNAME = `which hostname` );
chomp( my $CMD_MKDIR    = `which mkdir` );
chomp( my $CMD_RPM      = `which rpm` );
chomp( my $CMD_SORT     = `which sort` );
chomp( my $CMD_SVN      = `which svn` );
chomp( my $CMD_TAR      = `which tar` );
chomp( my $CMD_UNAME    = `which uname` );
chomp( my $CMD_UNIQ     = `which uniq` );
if ( !$CFG2SCM_OPT_DEBUG ) {
	open( STDERR, ">&SAVEERR" );
}
$ENV{ PATH } = '/bin:/usr/bin';
#
# predefined variables
#
sub si_now_gmt();
my $NOW = si_now_gmt();
chomp( my $HOSTNAME = `$CMD_HOSTNAME -f` );
my $CFG2SCM_OPT_TMP      = "/tmp/cfg2scm.$HOSTNAME.$NOW";
my $CFG2SCM_OPT_BASE_URL = "";
my $CFG2SCM_OPT_REPOS    = "";
my $CFG2SCM_OPT_USER     = "";
my $CFG2SCM_OPT_PASS     = "";
my $CFG2SCM_OPT_STORAGE  = "svn";
my $CFG2SCM_OPT_MESSAGE  = "autocommit by cfg2scm";
my $CFG2SCM_OPT_OUTFILE  = "/tmp/cfg2scm.$HOSTNAME.$NOW";
my $CFG2SCM_OPT_LIMIT    = 0;
my $CFG2SCM_OPT_NON_ROOT = "No";
my $CFG2SCM_OPT_GCONF    = "No";
my $CFG2SCM_SVN_AUTH     = "";
#
# static globals
#
my $CFG2SCM_COPYHOLDER            = "SuSE Linux, a Novell Business";
my $CFG2SCM_COPYRIGHT             = "2005-2006 $CFG2SCM_COPYHOLDER";
my $CFG2SCM_RELEASE               = "%%CFG2SCM_RELEASE%%";
my $CFG2SCM_SVNVERSION            = "%%CFG2SCM_SVNVERSION%%";
my $CFG2SCM_PREFIX                = "%%CFG2SCM_PREFIX%%";
my $CFG2SCM_CONSISTENCY_FILENAME  = "Configuration_Consistency.include";
my $CFG2SCM_FINDUNPACKED_FILENAME = "Find_Unpacked.include";
my $CFG2SCM_CONFIG_DIR            = "/var/lib/support";
my $CFG2SCM_CONFIG_FILE           = "/etc/sysconfig/cfg2scm";
#
# functions
#
# 1. si_now_gmt()
#
sub si_now_gmt() {
	my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday ) = gmtime( time );
	$year += 1900;
	$mon  = sprintf( "%02d", $mon );
	$mday = sprintf( "%02d", $mday );
	$hour = sprintf( "%02d", $hour );
	$gmt  = "gmt";
	return "$year$mon$mday$hour$gmt";
}
#
# 2. si_debug( text );
#
sub si_debug($) {
	my ( $text ) = @_;
	if ( $CFG2SCM_OPT_DEBUG ) {
		print $text, "\n";
	}
}

sub si_set_on_find($$$) {
	my ( $line, $parm, $VAR ) = @_;
	if ( $line =~ /$parm/ ) {
		my ( $dummy, $FOUND_VAR ) = split( /.*=\s*/, $line );
		$FOUND_VAR =~ s/^\"//;
		$FOUND_VAR =~ s/\"$//;
		return $FOUND_VAR;
	}
	return $VAR;
}

sub si_parse_conf_file($) {
	my $fname = shift;
	my $dummy;
	open( CONFIG_DATA, "$fname" ) || die "could not open \"$fname\": $!";
	while ( my $line = <CONFIG_DATA> ) {
		next if $line =~ /^#|^$/;
		chomp( $line );
		$CFG2SCM_OPT_TMP      = si_set_on_find( $line, "CFG2SCM_OPT_TMP",      $CFG2SCM_OPT_TMP );
		$CFG2SCM_OPT_BASE_URL = si_set_on_find( $line, "CFG2SCM_OPT_BASE_URL", $CFG2SCM_OPT_BASE_URL );
		$CFG2SCM_OPT_REPOS    = si_set_on_find( $line, "CFG2SCM_OPT_REPOS",    $CFG2SCM_OPT_REPOS );
		$CFG2SCM_OPT_USER     = si_set_on_find( $line, "CFG2SCM_OPT_USER",     $CFG2SCM_OPT_USER );
		$CFG2SCM_OPT_PASS     = si_set_on_find( $line, "CFG2SCM_OPT_PASS",     $CFG2SCM_OPT_PASS );
		$CFG2SCM_OPT_MESSAGE  = si_set_on_find( $line, "CFG2SCM_OPT_MESSAGE",  $CFG2SCM_OPT_MESSAGE );
		$CFG2SCM_OPT_STORAGE  = si_set_on_find( $line, "CFG2SCM_OPT_STORAGE",  $CFG2SCM_OPT_STORAGE );
		$CFG2SCM_OPT_OUTFILE  = si_set_on_find( $line, "CFG2SCM_OPT_OUTFILE",  $CFG2SCM_OPT_OUTFILE );
	}
	close( CONFIG_DATA );
}

sub si_prepare_config() {
	# read configuration file
	si_parse_conf_file( $CFG2SCM_CONFIG_FILE );
	# parse command line options
	GetOptions(
		'c|check-consistency' => \$CFG2SCM_OPT_CONSISTENCY,
		'b|base-url=s'        => \$CFG2SCM_OPT_BASE_URL,
		'd|debug'             => \$CFG2SCM_OPT_DEBUG,
		'f|find-unpacked'     => \$CFG2SCM_OPT_FINDUNPACKED,
		'h|help'              => \$CFG2SCM_OPT_HELP,
		'l|limit=i'           => \$CFG2SCM_OPT_LIMIT,
		'm|message=s'         => \$CFG2SCM_OPT_MESSAGE,
		'n|non-root=s'        => \$CFG2SCM_OPT_NON_ROOT,       # undocumented, testing only
		'o|outfile=s'         => \$CFG2SCM_OPT_OUTFILE,
		'p|password=s'        => \$CFG2SCM_OPT_PASS,
		'r|repository=s'      => \$CFG2SCM_OPT_REPOS,
		's|storage=s'         => \$CFG2SCM_OPT_STORAGE,
		'u|username=s'        => \$CFG2SCM_OPT_USER,
		'v|version'           => \$CFG2SCM_OPT_VERSION
	);
	# subversion authentication string
	if ( ( $CFG2SCM_OPT_USER ) && ( $CFG2SCM_OPT_USER ne "" ) ) {
		$CFG2SCM_SVN_AUTH = "--username $CFG2SCM_OPT_USER";
		if ( ( $CFG2SCM_OPT_PASS ) && ( $CFG2SCM_OPT_PASS ne "" ) ) {
			$CFG2SCM_SVN_AUTH = "--username $CFG2SCM_OPT_USER --password $CFG2SCM_OPT_PASS";
		}
	}
}

sub si_check_consistency($$$) {
	chomp( my ( $consconfdir, $consfile, $consdebug ) = @_ );
	my %configfiles = ();
	if ( !$consdebug ) {
		open( SAVEERR, ">&STDERR" );
		open( STDERR,  ">/dev/null" );
	}
	open( CONFIGFILES, "$CMD_RPM -qca |" );
	while ( <CONFIGFILES> ) {
		chomp();
		my $ccc = $_;
		if ( $ccc =~ /^\// ) {
			open( ONERPM, "$CMD_RPM -Vf --nodeps --noscript $ccc |" );
			while ( <ONERPM> ) {
				chomp();
				if ( $_ && ( $_ !~ /^missing/ ) ) {
					$ddd = substr( $_, index( $_, "/" ) );
					if ( $ddd eq $ccc ) {
						$configfiles{ $ddd } = 1;
					}
				}
			}
			close( ONERPM );
		}
	}
	close( CONFIGFILES );
	if ( !-d "$consconfdir" ) {
		mkdir $consconfdir;
	}
	open( CONSISTENCY, ">$consconfdir/$consfile" );
	print CONSISTENCY "\n\@files = (\n";
	foreach my $kkk ( sort keys %configfiles ) {
		print CONSISTENCY "\"", $kkk, "\",\n";
	}
	print CONSISTENCY ");\n\n";
	close( CONSISTENCY );
	if ( !$consdebug ) {
		open( STDERR, ">&SAVEERR" );
	}
}

sub si_find_unpacked($$$$) {
	chomp( my ( $funpconfdir, $funpfile, $ddd, $ignore_binary ) = @_ );
	my %configfiles = ();
	for $NN ( `$CMD_FIND $ddd -type f` ) {
		chomp $NN;
		chomp( my $res = `$CMD_RPM -qf $NN` );
		if ( $res =~ /is not owned by any package$/ ) {
			if ( ( $NN !~ /~$/ ) && ( -r $NN ) ) {
				chomp( $type = `$CMD_FILE -p -b $NN` );
				if ( $ignore_binary && ( ( $type =~ /^Berkeley DB/ ) || ( $type =~ /data/ ) ) ) {
					si_debug( sprintf "---\t", $type, "\t", $NN );
				} else {
					si_debug( sprintf "\t", $type, "\t", $NN );
					$configfiles{ $NN } = 1;
				}
			}
		}
	}
	if ( !-d "$funpconfdir" ) {
		mkdir $funpconfdir;
	}
	open( FINDUNPACKED, ">$funpconfdir/$funpfile" );
	print FINDUNPACKED "\n\@files = (\n";
	foreach my $kkk ( sort keys %configfiles ) {
		print FINDUNPACKED "\"", $kkk, "\",\n";
	}
	print FINDUNPACKED ");\n\n";
	close( FINDUNPACKED );
}

sub si_prepare() {
	mkdir( "$CFG2SCM_OPT_TMP" );
	chdir( "$CFG2SCM_OPT_TMP" );
	if ( $CFG2SCM_OPT_STORAGE eq "svn" ) {
		system( "$CMD_SVN co $CFG2SCM_SVN_AUTH $CFG2SCM_OPT_BASE_URL/$CFG2SCM_OPT_REPOS" );
	}
	chdir( "$CFG2SCM_OPT_TMP/$CFG2SCM_OPT_REPOS" );
}

sub si_add($) {
	chomp( my ( $fname ) = @_ );
	chomp( my $ddd       = `$CMD_DIRNAME $fname` );
	chomp( my $bbb       = `$CMD_BASENAME $fname` );
	if ( !$CFG2SCM_OPT_DEBUG ) {
		open( SAVEERR, ">&STDERR" );
		open( STDERR,  ">/dev/null" );
	}
	my ( $ff_dev, $ff_ino, $ff_mode, $ff_nlink, $ff_uid, $ff_gid, $ff_rdev, $ff_size, $ff_atime, $ff_mtime, $ff_ctime, $ff_blksize, $ff_blocks ) = stat( $fname );
	if ( ( $CFG2SCM_OPT_GCONF eq "No" ) && ( $fname =~ /etc\/opt\/gnome\/gconf/ ) ) {
		print "GCONF below /etc/opt/gnome/gconf/ found; skipped $fname\n";
	} elsif ( ( $CFG2SCM_OPT_LIMIT > 0 ) && ( $ff_size > $CFG2SCM_OPT_LIMIT ) ) {
		print "LIMIT exceed; skipped $fname\n";
	} else {
		system( " $CMD_MKDIR -p ./$ddd " );
		system( " cp -a $fname ./$ddd/ " );
		if ( $CFG2SCM_OPT_STORAGE eq "svn" ) {
			system( "$CMD_SVN add ./$fname" );
		}
	}
	if ( !$CFG2SCM_OPT_DEBUG ) {
		open( STDERR, ">&SAVEERR" );
	}
}

sub si_attention_no_filelists() {
	print "Attention:
\tno file-lists have been found. Please write your own
\tand put it as $CFG2SCM_CONFIG_DIR/<name>.include
\tor let CFG2SCM produce some with
\t--check-consistency
\t\tand/or
\t--find-unpacked\n";
}

sub si_read_and_eval_includes() {
	if ( -d $CFG2SCM_CONFIG_DIR ) {
		my @configfiles = ();
		@configfiles = `$CMD_FIND $CFG2SCM_CONFIG_DIR -iname "*.include" -type f`;
		if ( $#configfiles > -1 ) {
			for $NN ( @configfiles ) {
				chomp $NN;
				si_debug( $NN );
				%myfiles = ();
				do "$NN";
				foreach ( @files ) {
					$myfiles{ $_ } = 0;
				}
				foreach $mm ( sort keys %myfiles ) {
					if ( $mm !~ /proc/ ) {
						if ( -r $mm ) {
							si_add( $mm );
						}
					}
				}
			}
			return 0;
		} else {
			si_attention_no_filelists();
			return -1;
		}
	}
}

sub si_commit_cvs() {
	system( "$CMD_CVS -d $CFG2SCM_OPT_BASE_URL import -m '$CFG2SCM_OPT_MESSAGE' $CFG2SCM_OPT_REPOS 'v$NOW' auto" );
	#  cvs import -m "Imported sources" yoyodyne/RDIR yoyo start
}

sub si_store_tar() {
	chomp( my $basefilename  = `$CMD_BASENAME $CFG2SCM_OPT_OUTFILE .$CFG2SCM_OPT_STORAGE` );
	chomp( my $filedirname   = `$CMD_DIRNAME  $CFG2SCM_OPT_OUTFILE` );
	chomp( my $tmpdirname    = `$CMD_BASENAME $CFG2SCM_OPT_TMP` );
	chomp( my $tmpdirprefix  = `$CMD_DIRNAME  $CFG2SCM_OPT_TMP` );
	chomp( my $storefilename = $filedirname . "/" . $basefilename . "." . $CFG2SCM_OPT_STORAGE );
	si_debug( sprintf "tmp directory='$CFG2SCM_OPT_TMP'" );
	si_debug( sprintf "storefilename='$storefilename'" );
	chdir( $tmpdirprefix );
	if ( $CFG2SCM_OPT_STORAGE eq "tar" ) {
		system( "$CMD_TAR cspf  $storefilename $tmpdirname" );
	} elsif ( $CFG2SCM_OPT_STORAGE eq "tar.gz" ) {
		system( "$CMD_TAR cszpf $storefilename $tmpdirname" );
	} elsif ( $CFG2SCM_OPT_STORAGE eq "tar.bz2" ) {
		system( "$CMD_TAR csjpf $storefilename $tmpdirname" );
	}
}

sub si_commit_svn() {
	if ( !$CFG2SCM_OPT_DEBUG ) {
		open( SAVEERR, ">&STDERR" );
		open( STDERR,  ">/dev/null" );
		open( SAVEOUT, ">&STDOUT" );
		open( STDOUT,  ">/dev/null" );
	}
	system( "$CMD_SVN add *" );
	system( "$CMD_FIND . -iname '*.html' -exec $CMD_SVN propset svn:mime-type text/html {} \\; " );
	system( "$CMD_FIND . -iname '*.conf' -exec $CMD_SVN propset svn:mime-type text/plain {} \\; " );
	system( "$CMD_FIND . -iname '*.txt'  -exec $CMD_SVN propset svn:mime-type text/plain {} \\; " );
	system( "$CMD_FIND . -iname '*.png'  -exec $CMD_SVN propset svn:mime-type image/png {} \\; " );
	system( "$CMD_FIND . -iname '*.tex'  -exec $CMD_SVN propset svn:mime-type application/x-latex {} \\; " );
	system( "$CMD_FIND . -iname '*.dvi'  -exec $CMD_SVN propset svn:mime-type application/x-dvi {} \\; " );
	system( "$CMD_FIND . -iname '*.pdf'  -exec $CMD_SVN propset svn:mime-type application/pdf {} \\; " );
	system( "$CMD_FIND . -iname '*.doc'  -exec $CMD_SVN propset svn:mime-type application/msword {} \\; " );
	system( "$CMD_FIND . -iname '*.xls'  -exec $CMD_SVN propset svn:mime-type application/excel {} \\; " );
	system( "$CMD_FIND . -iname '*.sxw'  -exec $CMD_SVN propset svn:mime-type application/vnd.sun.xml.writer {} \\; " );
	system( "$CMD_FIND . -iname '*.sxi'  -exec $CMD_SVN propset svn:mime-type application/vnd.sun.xml.impress {} \\; " );
	system( "$CMD_FIND . -iname '*.sxc'  -exec $CMD_SVN propset svn:mime-type application/vnd.sun.xml.calc {} \\; " );
	system( "$CMD_FIND . -iname '*.ppt'  -exec $CMD_SVN propset svn:mime-type application/octet-stream {} \\; " );
	system( "$CMD_FIND . -iname '*.rpm'  -exec $CMD_SVN propset svn:mime-type application/octet-stream {} \\; " );
	if ( !$CFG2SCM_OPT_DEBUG ) {
		open( STDERR, ">&SAVEERR" );
		open( STDOUT, ">&SAVEOUT" );
	}
	system( "$CMD_SVN commit $CFG2SCM_SVN_AUTH -m '$CFG2SCM_OPT_MESSAGE' " );
}

sub si_print_version () {
	print "cfg2scm.pl -\tCheck configuration changes into SCM - Release ", $CFG2SCM_RELEASE, "-", $CFG2SCM_SVNVERSION, "\nCopyright (C) ", $CFG2SCM_COPYRIGHT, "\n";
}

sub si_print_help () {
	print "Options:
\t--base-url=<url>\tmain path to subversion repositories (mandatory)\n\t\t\t\tdefault: $CFG2SCM_OPT_BASE_URL
\t--repository=<name>\tname of the one repository to be used (mandatory)\n\t\t\t\tdefault: $CFG2SCM_OPT_REPOS
\t--debug
\t--check-consistency
\t--find-unpacked
\t--limit=<max filesize; 0=no limit>
\t--username=<username>
\t--password=<password>
\t--message=<commit msg>
\t--outfile=<file>
\t--storage=<svn|cvs|tar|tar.gz|tar.bz2>
\t--help\t\t\tthis page
\t--version\t\tprintout CFG2SCM version";
}

sub si_warn_no_root() {
	print "Attention:
\tyou have choosen to run the program as non-root-user;
\tthis is for testing purposes only.\n"
}

sub si_attention_no_config() {
	print "Attention:
\tyou have to set at least the 'storage' type,
\teither on the commandline or in the configuration-file
\t\t$CFG2SCM_CONFIG_FILE
\tFor storage types 'cvs' or 'svn', please also provide
\t'base-url' and 'repository'.\n";
}
#
# MAIN
#
{
	si_prepare_config();
	if ( $CFG2SCM_OPT_NON_ROOT eq "Yes" ) {
		si_warn_no_root();
	} else {
		my @myname = split /\//, $0;
		if ( $< != 0 ) {
			print( "Please run cfg2scm.pl as user root.\n" );
			exit;
		}
	}
	if ( $CFG2SCM_OPT_CONSISTENCY ) {
		print( "Checking consistency of configuration files. This might need a long time...\n" );
		si_check_consistency( $CFG2SCM_CONFIG_DIR, $CFG2SCM_CONSISTENCY_FILENAME, $CFG2SCM_OPT_DEBUG );
	}
	if ( $CFG2SCM_OPT_FINDUNPACKED ) {
		print( "Finding unpackaged files below /etc/. This might need a long time...\n" );
		si_find_unpacked( $CFG2SCM_CONFIG_DIR, $CFG2SCM_FINDUNPACKED_FILENAME, "/etc/", 1 );
	}
	if ( $CFG2SCM_OPT_VERSION ) {
		si_print_version();
	} elsif ( $CFG2SCM_OPT_HELP ) {
		si_print_help();
	} elsif ( ( !$CFG2SCM_OPT_BASE_URL ) || ( !$CFG2SCM_OPT_REPOS ) || ( !$CFG2SCM_OPT_STORAGE ) ) {
		si_attention_no_config();
		si_print_help();
	} else {
		si_prepare();
		if ( !si_read_and_eval_includes() ) {
			if ( $CFG2SCM_OPT_STORAGE eq "svn" ) {
				si_commit_svn();
			} elsif ( $CFG2SCM_OPT_STORAGE eq "cvs" ) {
				si_commit_cvs();
			} elsif (  ( $CFG2SCM_OPT_STORAGE eq "tar" )
				|| ( $CFG2SCM_OPT_STORAGE eq "tar.gz" )
				|| ( $CFG2SCM_OPT_STORAGE eq "tar.bz2" ) ) {
				si_store_tar();
			}
		}
	}
}
